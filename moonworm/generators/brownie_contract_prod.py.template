# Code generated by moonworm : https://github.com/bugout-dev/moonworm
# Moonworm version : {moonworm_version}

import argparse
import json
import os
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

from brownie import Contract, network, project
from brownie.network.contract import ContractContainer, ContractConstructor, TransactionReceiptType, ContractNotFound, _ContractBase
from eth_typing.evm import ChecksumAddress

CONTRACT_BUILD = {contract_build}

def get_abi_json(*args) -> List[Dict[str, Any]]:
    return CONTRACT_BUILD["abi"]

# This is workaround to deploy new contract which has only bytecode and abi in brownie
class CustomContract(Contract):
    @classmethod
    def from_build_object(cls, build: Dict[str, Any]):
        self = cls.__new__(cls)
        self.bytecode = build["bytecode"]
        _ContractBase.__init__(self, None, build, {{}})  # type: ignore
        self.deploy = ContractConstructor(self, self._name)
        self.addres = None
        return self

    def _add_from_tx(self, tx: TransactionReceiptType) -> None:
        tx._confirmed.wait()
        if tx.status and tx.contract_address is not None:
            self.address = tx.contract_address
            self.tx = tx
            self._owner = tx.sender
            try:
                self.at(tx.contract_address, tx.sender, tx)
            except ContractNotFound:
                # if the contract self-destructed during deployment
                pass

    def at(
        self,
        address: str,
        owner: Any = None,
        tx: Optional[TransactionReceiptType] = None,
        persist: bool = True,
    ) -> Contract:
        contract = Contract.from_abi(self._name, self.address, self.abi)
        contract.tx = self.tx
        return contract


def contract_from_build(*args) -> CustomContract:
    return CustomContract.from_build_object(CONTRACT_BUILD)


def boolean_argument_type(raw_value: str) -> bool:
    TRUE_VALUES = ["1", "t", "y", "true", "yes"]
    FALSE_VALUES = ["0", "f", "n", "false", "no"]

    if raw_value.lower() in TRUE_VALUES:
        return True
    elif raw_value.lower() in FALSE_VALUES:
        return False

    raise ValueError(
        f"Invalid boolean argument: {{raw_value}}. Value must be one of: {{','.join(TRUE_VALUES + FALSE_VALUES)}}"
    )

def bytes_argument_type(raw_value: str) -> str:
    return raw_value



{contract_body}
